<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CryptoAI - ì¢…í•© ì•”í˜¸í™”í ë¶„ì„ í”Œë«í¼</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.10.0/tf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.21/lodash.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: #fff;
            min-height: 100vh;
        }

        .header {
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(10px);
            padding: 1rem;
            text-align: center;
            border-bottom: 2px solid rgba(255,255,255,0.1);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: linear-gradient(45deg, #FFD700, #FF6B6B);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 2rem;
        }

        .control-panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .card {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 1.5rem;
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .card h3 {
            color: #FFD700;
            margin-bottom: 1rem;
            font-size: 1.2rem;
            border-bottom: 2px solid #FFD700;
            padding-bottom: 0.5rem;
        }

        .input-group {
            margin-bottom: 1rem;
        }

        .input-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }

        .input-group input, .input-group select, .input-group textarea {
            width: 100%;
            padding: 0.8rem;
            border: none;
            border-radius: 8px;
            background: rgba(255,255,255,0.2);
            color: #fff;
            font-size: 1rem;
        }

        .input-group input::placeholder {
            color: rgba(255,255,255,0.7);
        }

        .btn {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            color: white;
            border: none;
            padding: 0.8rem 2rem;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1rem;
            font-weight: 600;
            transition: all 0.3s ease;
            margin: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #FF5252, #26C6DA);
        }

        .btn-secondary {
            background: linear-gradient(45deg, #9C27B0, #673AB7);
        }

        .btn-secondary:hover {
            background: linear-gradient(45deg, #8E24AA, #5E35B1);
        }

        .chart-container {
            position: relative;
            height: 400px;
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 1rem;
            margin: 1rem 0;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 0.5rem;
        }

        .status-training { background: #FF9800; }
        .status-ready { background: #4CAF50; }
        .status-error { background: #F44336; }

        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }

        .metric-card {
            background: linear-gradient(135deg, rgba(255,107,107,0.2), rgba(78,205,196,0.2));
            border-radius: 10px;
            padding: 1rem;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.1);
        }

        .metric-value {
            font-size: 2rem;
            font-weight: 700;
            color: #FFD700;
            margin-bottom: 0.5rem;
        }

        .model-status {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0.5rem;
            background: rgba(255,255,255,0.1);
            border-radius: 8px;
            margin: 0.5rem 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 1rem 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4ECDC4, #44A08D);
            border-radius: 4px;
            transition: width 0.3s ease;
        }

        .data-preview {
            max-height: 200px;
            overflow-y: auto;
            background: rgba(0,0,0,0.3);
            border-radius: 8px;
            padding: 1rem;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .ensemble-weights {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin: 1rem 0;
        }

        .weight-control {
            text-align: center;
        }

        .weight-slider {
            width: 100%;
            margin: 0.5rem 0;
        }

        .prediction-result {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 10px;
            padding: 2rem;
            text-align: center;
            margin: 1rem 0;
        }

        .classification-result {
            display: inline-block;
            padding: 0.5rem 1rem;
            border-radius: 25px;
            margin: 0.5rem;
            font-weight: 600;
        }

        .bull { background: #4CAF50; }
        .bear { background: #F44336; }
        .neutral { background: #FF9800; }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .tabs {
            display: flex;
            margin-bottom: 2rem;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
        }

        .tab {
            flex: 1;
            padding: 1rem;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            border: none;
            background: transparent;
            color: #fff;
        }

        .tab.active {
            background: rgba(255,215,0,0.3);
            color: #FFD700;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .alert {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-weight: 600;
        }

        .alert-success { background: rgba(76,175,80,0.3); border-left: 4px solid #4CAF50; }
        .alert-error { background: rgba(244,67,54,0.3); border-left: 4px solid #F44336; }
        .alert-warning { background: rgba(255,152,0,0.3); border-left: 4px solid #FF9800; }

        .feature-importance {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1rem 0;
        }

        .backtest-results {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
        }

        .strategy-card {
            background: linear-gradient(135deg, rgba(156,39,176,0.3), rgba(103,58,183,0.3));
            border-radius: 10px;
            padding: 1.5rem;
            margin: 1rem 0;
            border: 1px solid rgba(255,255,255,0.1);
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸš€ CryptoAI ì¢…í•© ë¶„ì„ í”Œë«í¼</h1>
        <p>AI ê¸°ë°˜ ì•”í˜¸í™”í ë¶„ì„, ì˜ˆì¸¡ ë° ë¶„ë¥˜ ì†”ë£¨ì…˜</p>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('data')">ğŸ“Š ë°ì´í„° ê´€ë¦¬</button>
            <button class="tab" onclick="switchTab('models')">ğŸ¤– ëª¨ë¸ í›ˆë ¨</button>
            <button class="tab" onclick="switchTab('prediction')">ğŸ”® ì˜ˆì¸¡/ë¶„ë¥˜</button>
            <button class="tab" onclick="switchTab('ensemble')">âš¡ ì•™ìƒë¸”</button>
            <button class="tab" onclick="switchTab('backtest')">ğŸ“ˆ ë°±í…ŒìŠ¤íŒ…</button>
            <button class="tab" onclick="switchTab('realtime')">ğŸ”´ ì‹¤ì‹œê°„</button>
        </div>

        <!-- ë°ì´í„° ê´€ë¦¬ íƒ­ -->
        <div id="data-tab" class="tab-content active">
            <div class="grid">
                <div class="card">
                    <h3>ğŸ’¾ ë°ì´í„° ë¡œë“œ</h3>
                    <div class="input-group">
                        <label>ì•”í˜¸í™”í ì„ íƒ</label>
                        <select id="cryptoSelect">
                            <option value="BTC">Bitcoin (BTC)</option>
                            <option value="ETH">Ethereum (ETH)</option>
                            <option value="BNB">Binance Coin (BNB)</option>
                            <option value="ADA">Cardano (ADA)</option>
                            <option value="SOL">Solana (SOL)</option>
                        </select>
                    </div>
                    <div class="input-group">
                        <label>ì‹œê°„ ë²”ìœ„</label>
                        <select id="timeRange">
                            <option value="1d">1ì¼</option>
                            <option value="7d">1ì£¼</option>
                            <option value="30d">1ê°œì›”</option>
                            <option value="90d">3ê°œì›”</option>
                            <option value="365d">1ë…„</option>
                        </select>
                    </div>
                    <button class="btn" onclick="generateSampleData()">ìƒ˜í”Œ ë°ì´í„° ìƒì„±</button>
                    <button class="btn btn-secondary" onclick="loadRealData()">ì‹¤ì‹œê°„ ë°ì´í„° ë¡œë“œ</button>
                </div>

                <div class="card">
                    <h3>ğŸ“ˆ ë°ì´í„° ì‹œê°í™”</h3>
                    <div class="chart-container">
                        <canvas id="priceChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ” ë°ì´í„° ë¯¸ë¦¬ë³´ê¸°</h3>
                <div class="data-preview" id="dataPreview">
                    ë°ì´í„°ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”...
                </div>
            </div>
        </div>

        <!-- ëª¨ë¸ í›ˆë ¨ íƒ­ -->
        <div id="models-tab" class="tab-content">
            <div class="grid">
                <div class="card">
                    <h3>ğŸ§  ë¶„ë¥˜ ëª¨ë¸ë“¤</h3>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>LSTM ë¶„ë¥˜ê¸° (ë¶ˆ/ê³°/ì¤‘ë¦½)</span>
                        <button class="btn" onclick="trainClassificationModel('lstm')">í›ˆë ¨</button>
                    </div>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>Random Forest (íŒ¨í„´ ë¶„ë¥˜)</span>
                        <button class="btn" onclick="trainClassificationModel('rf')">í›ˆë ¨</button>
                    </div>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>SVM (íŠ¸ë Œë“œ ë¶„ë¥˜)</span>
                        <button class="btn" onclick="trainClassificationModel('svm')">í›ˆë ¨</button>
                    </div>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>CNN (ì°¨íŠ¸ íŒ¨í„´)</span>
                        <button class="btn" onclick="trainClassificationModel('cnn')">í›ˆë ¨</button>
                    </div>
                </div>

                <div class="card">
                    <h3>ğŸ“Š íšŒê·€ ëª¨ë¸ë“¤</h3>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>LSTM íšŒê·€ (ê°€ê²© ì˜ˆì¸¡)</span>
                        <button class="btn" onclick="trainRegressionModel('lstm')">í›ˆë ¨</button>
                    </div>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>GRU (ë‹¨ê¸° ì˜ˆì¸¡)</span>
                        <button class="btn" onclick="trainRegressionModel('gru')">í›ˆë ¨</button>
                    </div>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>Linear Regression</span>
                        <button class="btn" onclick="trainRegressionModel('linear')">í›ˆë ¨</button>
                    </div>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>ARIMA ëª¨ë¸</span>
                        <button class="btn" onclick="trainRegressionModel('arima')">í›ˆë ¨</button>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>âš™ï¸ í•˜ì´í¼íŒŒë¼ë¯¸í„° íŠœë‹</h3>
                <div class="grid">
                    <div class="input-group">
                        <label>ì‹œí€€ìŠ¤ ê¸¸ì´</label>
                        <input type="number" id="sequenceLength" value="50" min="10" max="200">
                    </div>
                    <div class="input-group">
                        <label>ë°°ì¹˜ í¬ê¸°</label>
                        <input type="number" id="batchSize" value="32" min="8" max="128">
                    </div>
                    <div class="input-group">
                        <label>í•™ìŠµë¥ </label>
                        <input type="number" id="learningRate" value="0.001" step="0.0001">
                    </div>
                    <div class="input-group">
                        <label>ì—í¬í¬</label>
                        <input type="number" id="epochs" value="100" min="10" max="500">
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ“Š í›ˆë ¨ ì§„í–‰ ìƒí™©</h3>
                <div class="progress-bar">
                    <div class="progress-fill" id="trainingProgress" style="width: 0%"></div>
                </div>
                <div id="trainingLog">í›ˆë ¨ì„ ì‹œì‘í•˜ë ¤ë©´ ìœ„ì˜ ëª¨ë¸ì„ ì„ íƒí•˜ì„¸ìš”...</div>
            </div>
        </div>

        <!-- ì˜ˆì¸¡/ë¶„ë¥˜ íƒ­ -->
        <div id="prediction-tab" class="tab-content">
            <div class="grid">
                <div class="card">
                    <h3>ğŸ”® ê°€ê²© ì˜ˆì¸¡</h3>
                    <div class="input-group">
                        <label>ì˜ˆì¸¡ ê¸°ê°„ (ì‹œê°„)</label>
                        <input type="number" id="predictionHours" value="24" min="1" max="168">
                    </div>
                    <button class="btn" onclick="makePrediction()">ê°€ê²© ì˜ˆì¸¡ ì‹¤í–‰</button>
                    
                    <div class="prediction-result" id="predictionResult" style="display: none;">
                        <h4>ì˜ˆì¸¡ ê²°ê³¼</h4>
                        <div class="metric-value" id="predictedPrice">$0.00</div>
                        <p>ì‹ ë¢°ë„: <span id="predictionConfidence">0%</span></p>
                    </div>
                </div>

                <div class="card">
                    <h3>ğŸ“ˆ íŠ¸ë Œë“œ ë¶„ë¥˜</h3>
                    <button class="btn" onclick="classifyTrend()">íŠ¸ë Œë“œ ë¶„ì„</button>
                    
                    <div id="classificationResults" style="display: none;">
                        <h4>ë¶„ë¥˜ ê²°ê³¼</h4>
                        <div id="trendResults"></div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ“Š ì˜ˆì¸¡ ì°¨íŠ¸</h3>
                <div class="chart-container">
                    <canvas id="predictionChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ¯ ëª¨ë¸ ì„±ëŠ¥ ì§€í‘œ</h3>
                <div class="results-grid" id="performanceMetrics">
                    <div class="metric-card">
                        <div class="metric-value" id="mae">-</div>
                        <div>í‰ê·  ì ˆëŒ€ ì˜¤ì°¨ (MAE)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="rmse">-</div>
                        <div>í‰ê·  ì œê³±ê·¼ ì˜¤ì°¨ (RMSE)</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="mape">-</div>
                        <div>í‰ê·  ì ˆëŒ€ ë°±ë¶„ìœ¨ ì˜¤ì°¨</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-value" id="accuracy">-</div>
                        <div>ë¶„ë¥˜ ì •í™•ë„</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ì•™ìƒë¸” íƒ­ -->
        <div id="ensemble-tab" class="tab-content">
            <div class="card">
                <h3>âš¡ ì•™ìƒë¸” ëª¨ë¸ êµ¬ì„±</h3>
                <p>ì—¬ëŸ¬ ëª¨ë¸ì˜ ì˜ˆì¸¡ì„ ê²°í•©í•˜ì—¬ ë” ì •í™•í•œ ê²°ê³¼ë¥¼ ë„ì¶œí•©ë‹ˆë‹¤.</p>
                
                <div class="ensemble-weights">
                    <div class="weight-control">
                        <label>LSTM ê°€ì¤‘ì¹˜</label>
                        <input type="range" class="weight-slider" id="lstmWeight" min="0" max="1" step="0.1" value="0.3">
                        <span id="lstmWeightValue">0.3</span>
                    </div>
                    <div class="weight-control">
                        <label>GRU ê°€ì¤‘ì¹˜</label>
                        <input type="range" class="weight-slider" id="gruWeight" min="0" max="1" step="0.1" value="0.25">
                        <span id="gruWeightValue">0.25</span>
                    </div>
                    <div class="weight-control">
                        <label>Random Forest ê°€ì¤‘ì¹˜</label>
                        <input type="range" class="weight-slider" id="rfWeight" min="0" max="1" step="0.1" value="0.25">
                        <span id="rfWeightValue">0.25</span>
                    </div>
                    <div class="weight-control">
                        <label>Linear ê°€ì¤‘ì¹˜</label>
                        <input type="range" class="weight-slider" id="linearWeight" min="0" max="1" step="0.1" value="0.2">
                        <span id="linearWeightValue">0.2</span>
                    </div>
                </div>
                
                <button class="btn" onclick="trainEnsemble()">ì•™ìƒë¸” ëª¨ë¸ í›ˆë ¨</button>
                <button class="btn btn-secondary" onclick="runEnsemblePrediction()">ì•™ìƒë¸” ì˜ˆì¸¡ ì‹¤í–‰</button>
            </div>

            <div class="grid">
                <div class="card">
                    <h3>ğŸ† ì•™ìƒë¸” ì„±ëŠ¥</h3>
                    <div class="chart-container">
                        <canvas id="ensemblePerformanceChart"></canvas>
                    </div>
                </div>

                <div class="card">
                    <h3>ğŸ¯ ëª¨ë¸ë³„ ê¸°ì—¬ë„</h3>
                    <div class="chart-container">
                        <canvas id="modelContributionChart"></canvas>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ“Š ìŠ¤íƒœí‚¹ ì•™ìƒë¸”</h3>
                <p>ë©”íƒ€ ëª¨ë¸ì„ ì‚¬ìš©í•˜ì—¬ ê¸°ë³¸ ëª¨ë¸ë“¤ì˜ ì˜ˆì¸¡ì„ ìµœì ìœ¼ë¡œ ê²°í•©í•©ë‹ˆë‹¤.</p>
                <div class="input-group">
                    <label>ë©”íƒ€ ëª¨ë¸ ì„ íƒ</label>
                    <select id="metaModel">
                        <option value="linear">ì„ í˜• íšŒê·€</option>
                        <option value="ridge">Ridge íšŒê·€</option>
                        <option value="xgboost">XGBoost</option>
                        <option value="neural">ì‹ ê²½ë§</option>
                    </select>
                </div>
                <button class="btn" onclick="trainStackingEnsemble()">ìŠ¤íƒœí‚¹ ì•™ìƒë¸” í›ˆë ¨</button>
            </div>
        </div>

        <!-- ë°±í…ŒìŠ¤íŒ… íƒ­ -->
        <div id="backtest-tab" class="tab-content">
            <div class="card">
                <h3>ğŸ“ˆ ë°±í…ŒìŠ¤íŒ… ì„¤ì •</h3>
                <div class="grid">
                    <div class="input-group">
                        <label>ì´ˆê¸° ìë³¸ ($)</label>
                        <input type="number" id="initialCapital" value="10000" min="1000">
                    </div>
                    <div class="input-group">
                        <label>ê±°ë˜ ìˆ˜ìˆ˜ë£Œ (%)</label>
                        <input type="number" id="tradingFee" value="0.1" step="0.01" min="0">
                    </div>
                    <div class="input-group">
                        <label>ë¦¬ë°¸ëŸ°ì‹± ì£¼ê¸° (ì¼)</label>
                        <input type="number" id="rebalancePeriod" value="7" min="1">
                    </div>
                    <div class="input-group">
                        <label>ë°±í…ŒìŠ¤íŠ¸ ê¸°ê°„ (ê°œì›”)</label>
                        <input type="number" id="backtestPeriod" value="12" min="1" max="36">
                    </div>
                </div>
                <button class="btn" onclick="runBacktest()">ë°±í…ŒìŠ¤íŒ… ì‹¤í–‰</button>
            </div>

            <div class="grid">
                <div class="card">
                    <h3>ğŸ’° ìˆ˜ìµë¥  ë¶„ì„</h3>
                    <div class="chart-container">
                        <canvas id="returnsChart"></canvas>
                    </div>
                </div>

                <div class="card">
                    <h3>ğŸ“Š í¬íŠ¸í´ë¦¬ì˜¤ ì„±ê³¼</h3>
                    <div class="backtest-results" id="backtestResults" style="display: none;">
                        <div class="results-grid">
                            <div class="metric-card">
                                <div class="metric-value" id="totalReturn">-</div>
                                <div>ì´ ìˆ˜ìµë¥ </div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value" id="sharpeRatio">-</div>
                                <div>ìƒ¤í”„ ë¹„ìœ¨</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value" id="maxDrawdown">-</div>
                                <div>ìµœëŒ€ ë‚™í­</div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-value" id="winRate">-</div>
                                <div>ìŠ¹ë¥ </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ¯ ì „ëµ ë¹„êµ</h3>
                <div class="strategy-card">
                    <h4>ğŸ¤– AI ì˜ˆì¸¡ ì „ëµ</h4>
                    <p>ì•™ìƒë¸” ëª¨ë¸ ê¸°ë°˜ ìë™ ë§¤ë§¤ ì „ëµ</p>
                    <div class="metric-value" id="aiStrategyReturn">-</div>
                </div>
                <div class="strategy-card">
                    <h4>ğŸ“ˆ Buy & Hold</h4>
                    <p>ë‹¨ìˆœ ë³´ìœ  ì „ëµ</p>
                    <div class="metric-value" id="holdStrategyReturn">-</div>
                </div>
                <div class="strategy-card">
                    <h4>ğŸ“Š ì´ë™í‰ê·  ì „ëµ</h4>
                    <p>ê¸°ìˆ ì  ë¶„ì„ ê¸°ë°˜ ì „ëµ</p>
                    <div class="metric-value" id="maStrategyReturn">-</div>
                </div>
            </div>
        </div>

        <!-- ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ íƒ­ -->
        <div id="realtime-tab" class="tab-content">
            <div class="grid">
                <div class="card">
                    <h3>ğŸ”´ ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§</h3>
                    <div class="model-status">
                        <span><span class="status-indicator status-ready"></span>ì‹¤ì‹œê°„ ë°ì´í„° ìŠ¤íŠ¸ë¦¼</span>
                        <button class="btn" id="realtimeToggle" onclick="toggleRealtime()">ì‹œì‘</button>
                    </div>
                    <div class="alert alert-success" id="realtimeStatus" style="display: none;">
                        ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.
                    </div>
                </div>

                <div class="card">
                    <h3>âš¡ ì‹¤ì‹œê°„ ì˜ˆì¸¡</h3>
                    <div class="prediction-result">
                        <h4>í˜„ì¬ ì˜ˆì¸¡</h4>
                        <div class="metric-value" id="realtimePrediction">$0.00</div>
                        <p>ë§ˆì§€ë§‰ ì—…ë°ì´íŠ¸: <span id="lastUpdate">-</span></p>
                    </div>
                </div>
            </div>

            <div class="card">
                <h3>ğŸ“Š ì‹¤ì‹œê°„ ì°¨íŠ¸</h3>
                <div class="chart-container">
                    <canvas id="realtimeChart"></canvas>
                </div>
            </div>

            <div class="card">
                <h3>ğŸš¨ ì•Œë¦¼ ì„¤ì •</h3>
                <div class="grid">
                    <div class="input-group">
                        <label>ê°€ê²© ì•Œë¦¼ (ìƒí•œ)</label>
                        <input type="number" id="priceAlertUpper" placeholder="ìƒí•œ ê°€ê²©">
                    </div>
                    <div class="input-group">
                        <label>ê°€ê²© ì•Œë¦¼ (í•˜í•œ)</label>
                        <input type="number" id="priceAlertLower" placeholder="í•˜í•œ ê°€ê²©">
                    </div>
                    <div class="input-group">
                        <label>ë³€ë™ì„± ì•Œë¦¼ (%)</label>
                        <input type="number" id="volatilityAlert" value="10" min="1" max="50">
                    </div>
                </div>
                <button class="btn" onclick="setAlerts()">ì•Œë¦¼ ì„¤ì •</button>
            </div>

            <div class="card">
                <h3>ğŸ“± ìë™ ê±°ë˜ ì„¤ì •</h3>
                <div class="input-group">
                    <label>ìë™ ê±°ë˜ í™œì„±í™”</label>
                    <select id="autoTrading">
                        <option value="false">ë¹„í™œì„±í™”</option>
                        <option value="true">í™œì„±í™”</option>
                    </select>
                </div>
                <div class="input-group">
                    <label>ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° (%)</label>
                    <input type="number" id="maxPosition" value="10" min="1" max="100">
                </div>
                <div class="input-group">
                    <label>ì†ì ˆë§¤ ë¹„ìœ¨ (%)</label>
                    <input type="number" id="stopLoss" value="5" min="1" max="20">
                </div>
                <div class="input-group">
                    <label>ìµì ˆë§¤ ë¹„ìœ¨ (%)</label>
                    <input type="number" id="takeProfit" value="15" min="5" max="50">
                </div>
                <button class="btn btn-secondary" onclick="configAutoTrading()">ìë™ê±°ë˜ ì„¤ì •</button>
            </div>
        </div>
    </div>

    <script>
        // ì „ì—­ ë³€ìˆ˜ë“¤
        let cryptoData = [];
        let models = {
            classification: {},
            regression: {},
            ensemble: null
        };
        let charts = {};
        let realtimeInterval = null;
        let isRealtimeActive = false;

        // íƒ­ ì „í™˜ í•¨ìˆ˜
        function switchTab(tabName) {
            // ëª¨ë“  íƒ­ê³¼ ì½˜í…ì¸  ë¹„í™œì„±í™”
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.style.display = 'none');
            
            // ì„ íƒëœ íƒ­ í™œì„±í™”
            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').style.display = 'block';
            document.getElementById(tabName + '-tab').classList.add('active');
        }

        // ìƒ˜í”Œ ë°ì´í„° ìƒì„± í•¨ìˆ˜
        function generateSampleData() {
            const crypto = document.getElementById('cryptoSelect').value;
            const range = document.getElementById('timeRange').value;
            
            let dataPoints = 100;
            switch(range) {
                case '1d': dataPoints = 24; break;
                case '7d': dataPoints = 168; break;
                case '30d': dataPoints = 720; break;
                case '90d': dataPoints = 2160; break;
                case '365d': dataPoints = 8760; break;
            }

            cryptoData = [];
            let basePrice = crypto === 'BTC' ? 45000 : crypto === 'ETH' ? 3000 : 500;
            let currentPrice = basePrice;
            
            for (let i = 0; i < dataPoints; i++) {
                const timestamp = new Date(Date.now() - (dataPoints - i) * 3600000);
                const volatility = (Math.random() - 0.5) * 0.05; // Â±2.5% ë³€ë™ì„±
                currentPrice *= (1 + volatility);
                
                const volume = Math.random() * 1000000 + 500000;
                const high = currentPrice * (1 + Math.random() * 0.02);
                const low = currentPrice * (1 - Math.random() * 0.02);
                
                cryptoData.push({
                    timestamp: timestamp,
                    open: currentPrice,
                    high: high,
                    low: low,
                    close: currentPrice,
                    volume: volume,
                    price: currentPrice
                });
            }

            updateDataPreview();
            updatePriceChart();
            showAlert('success', `${crypto} ìƒ˜í”Œ ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        // ì‹¤ì‹œê°„ ë°ì´í„° ë¡œë“œ (ëª¨ì˜)
        function loadRealData() {
            showAlert('warning', 'ì‹¤ì‹œê°„ ë°ì´í„° API ì—°ë™ ì¤‘...');
            setTimeout(() => {
                generateSampleData(); // ì‹¤ì œ êµ¬í˜„ì‹œ API í˜¸ì¶œë¡œ ëŒ€ì²´
                showAlert('success', 'ì‹¤ì‹œê°„ ë°ì´í„°ê°€ ë¡œë“œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }, 2000);
        }

        // ë°ì´í„° ë¯¸ë¦¬ë³´ê¸° ì—…ë°ì´íŠ¸
        function updateDataPreview() {
            const preview = document.getElementById('dataPreview');
            if (cryptoData.length === 0) {
                preview.textContent = 'ë°ì´í„°ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”...';
                return;
            }

            let previewText = `ë°ì´í„° í¬ì¸íŠ¸: ${cryptoData.length}\n`;
            previewText += `ì‹œê°„ ë²”ìœ„: ${cryptoData[0].timestamp.toLocaleString()} - ${cryptoData[cryptoData.length-1].timestamp.toLocaleString()}\n\n`;
            previewText += 'ìµœê·¼ 10ê°œ ë°ì´í„°:\n';
            previewText += 'Timestamp\t\tPrice\t\tVolume\n';
            
            cryptoData.slice(-10).forEach(point => {
                previewText += `${point.timestamp.toLocaleString()}\t${point.price.toFixed(2)}\t${point.volume.toFixed(0)}\n`;
            });

            preview.textContent = previewText;
        }

        // ê°€ê²© ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updatePriceChart() {
            const ctx = document.getElementById('priceChart').getContext('2d');
            
            if (charts.priceChart) {
                charts.priceChart.destroy();
            }

            charts.priceChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: cryptoData.map(d => d.timestamp.toLocaleTimeString()),
                    datasets: [{
                        label: 'ê°€ê²©',
                        data: cryptoData.map(d => d.price),
                        borderColor: 'rgb(255, 215, 0)',
                        backgroundColor: 'rgba(255, 215, 0, 0.1)',
                        tension: 0.1
                    }, {
                        label: 'ê±°ë˜ëŸ‰',
                        data: cryptoData.map(d => d.volume / 1000),
                        type: 'bar',
                        yAxisID: 'y1',
                        backgroundColor: 'rgba(78, 205, 196, 0.3)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#fff' } }
                    },
                    scales: {
                        x: { ticks: { color: '#fff' } },
                        y: { 
                            ticks: { color: '#fff' },
                            position: 'left'
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            ticks: { color: '#fff' },
                            grid: { drawOnChartArea: false }
                        }
                    }
                }
            });
        }

        // ë¶„ë¥˜ ëª¨ë¸ í›ˆë ¨
        async function trainClassificationModel(modelType) {
            if (cryptoData.length === 0) {
                showAlert('error', 'ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”.');
                return;
            }

            const button = event.target;
            button.innerHTML = '<span class="loading"></span> í›ˆë ¨ ì¤‘...';
            button.disabled = true;

            await simulateTraining();

            // ëª¨ì˜ ë¶„ë¥˜ ëª¨ë¸ ìƒì„±
            models.classification[modelType] = {
                type: modelType,
                accuracy: Math.random() * 0.3 + 0.65, // 65-95% ì •í™•ë„
                trained: true,
                predict: function(data) {
                    const trend = Math.random();
                    if (trend < 0.33) return 'bear';
                    if (trend < 0.66) return 'neutral';
                    return 'bull';
                }
            };

            button.innerHTML = 'ì¬í›ˆë ¨';
            button.disabled = false;
            showAlert('success', `${modelType.toUpperCase()} ë¶„ë¥˜ ëª¨ë¸ì´ ì„±ê³µì ìœ¼ë¡œ í›ˆë ¨ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        // íšŒê·€ ëª¨ë¸ í›ˆë ¨
        async function trainRegressionModel(modelType) {
            if (cryptoData.length === 0) {
                showAlert('error', 'ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”.');
                return;
            }

            const button = event.target;
            button.innerHTML = '<span class="loading"></span> í›ˆë ¨ ì¤‘...';
            button.disabled = true;

            await simulateTraining();

            // ëª¨ì˜ íšŒê·€ ëª¨ë¸ ìƒì„±
            models.regression[modelType] = {
                type: modelType,
                rmse: Math.random() * 100 + 50,
                mae: Math.random() * 50 + 25,
                trained: true,
                predict: function(data) {
                    const currentPrice = data[data.length - 1].price;
                    const change = (Math.random() - 0.5) * 0.1; // Â±5% ë³€í™”
                    return currentPrice * (1 + change);
                }
            };

            button.innerHTML = 'ì¬í›ˆë ¨';
            button.disabled = false;
            showAlert('success', `${modelType.toUpperCase()} íšŒê·€ ëª¨ë¸ì´ ì„±ê³µì ìœ¼ë¡œ í›ˆë ¨ë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        // í›ˆë ¨ ì‹œë®¬ë ˆì´ì…˜
        async function simulateTraining() {
            const progressBar = document.getElementById('trainingProgress');
            const trainingLog = document.getElementById('trainingLog');
            
            for (let i = 0; i <= 100; i += 5) {
                progressBar.style.width = i + '%';
                trainingLog.textContent = `í›ˆë ¨ ì§„í–‰ ì¤‘... ${i}%`;
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            trainingLog.textContent = 'í›ˆë ¨ ì™„ë£Œ!';
        }

        // ê°€ê²© ì˜ˆì¸¡
        function makePrediction() {
            if (cryptoData.length === 0) {
                showAlert('error', 'ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”.');
                return;
            }

            if (Object.keys(models.regression).length === 0) {
                showAlert('error', 'ë¨¼ì € íšŒê·€ ëª¨ë¸ì„ í›ˆë ¨í•´ì£¼ì„¸ìš”.');
                return;
            }

            const hours = parseInt(document.getElementById('predictionHours').value);
            const currentPrice = cryptoData[cryptoData.length - 1].price;
            
            // ì•™ìƒë¸” ì˜ˆì¸¡ (ì—¬ëŸ¬ ëª¨ë¸ì˜ í‰ê· )
            let predictions = [];
            Object.values(models.regression).forEach(model => {
                predictions.push(model.predict(cryptoData));
            });
            
            const ensemblePrediction = predictions.reduce((a, b) => a + b, 0) / predictions.length;
            const confidence = Math.random() * 30 + 70; // 70-100% ì‹ ë¢°ë„

            // ê²°ê³¼ í‘œì‹œ
            document.getElementById('predictionResult').style.display = 'block';
            document.getElementById('predictedPrice').textContent = `${ensemblePrediction.toFixed(2)}`;
            document.getElementById('predictionConfidence').textContent = `${confidence.toFixed(1)}%`;

            // ì„±ëŠ¥ ì§€í‘œ ì—…ë°ì´íŠ¸
            updatePerformanceMetrics();
            
            // ì˜ˆì¸¡ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
            updatePredictionChart(ensemblePrediction, hours);

            showAlert('success', `${hours}ì‹œê°„ í›„ ê°€ê²© ì˜ˆì¸¡ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.`);
        }

        // íŠ¸ë Œë“œ ë¶„ë¥˜
        function classifyTrend() {
            if (cryptoData.length === 0) {
                showAlert('error', 'ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”.');
                return;
            }

            if (Object.keys(models.classification).length === 0) {
                showAlert('error', 'ë¨¼ì € ë¶„ë¥˜ ëª¨ë¸ì„ í›ˆë ¨í•´ì£¼ì„¸ìš”.');
                return;
            }

            const results = document.getElementById('classificationResults');
            const trendResults = document.getElementById('trendResults');
            
            results.style.display = 'block';
            trendResults.innerHTML = '';

            // ê° ë¶„ë¥˜ ëª¨ë¸ì˜ ì˜ˆì¸¡ ê²°ê³¼
            Object.entries(models.classification).forEach(([modelType, model]) => {
                const prediction = model.predict(cryptoData);
                const confidence = (model.accuracy * 100).toFixed(1);
                
                const resultDiv = document.createElement('div');
                resultDiv.className = `classification-result ${prediction}`;
                resultDiv.innerHTML = `
                    <strong>${modelType.toUpperCase()}</strong>: 
                    ${prediction.toUpperCase()} (${confidence}% ì‹ ë¢°ë„)
                `;
                trendResults.appendChild(resultDiv);
            });

            showAlert('success', 'íŠ¸ë Œë“œ ë¶„ë¥˜ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        // ì„±ëŠ¥ ì§€í‘œ ì—…ë°ì´íŠ¸
        function updatePerformanceMetrics() {
            const metrics = {
                mae: (Math.random() * 50 + 25).toFixed(2),
                rmse: (Math.random() * 100 + 50).toFixed(2),
                mape: (Math.random() * 10 + 2).toFixed(2) + '%',
                accuracy: (Math.random() * 30 + 70).toFixed(1) + '%'
            };

            document.getElementById('mae').textContent = metrics.mae;
            document.getElementById('rmse').textContent = metrics.rmse;
            document.getElementById('mape').textContent = metrics.mape;
            document.getElementById('accuracy').textContent = metrics.accuracy;
        }

        // ì˜ˆì¸¡ ì°¨íŠ¸ ì—…ë°ì´íŠ¸
        function updatePredictionChart(prediction, hours) {
            const ctx = document.getElementById('predictionChart').getContext('2d');
            
            if (charts.predictionChart) {
                charts.predictionChart.destroy();
            }

            const historicalData = cryptoData.slice(-50); // ìµœê·¼ 50ê°œ ë°ì´í„°
            const futureData = [];
            
            // ë¯¸ë˜ ì˜ˆì¸¡ ë°ì´í„° ìƒì„±
            let currentPrice = prediction;
            for (let i = 0; i < hours; i++) {
                const futureTime = new Date(Date.now() + i * 3600000);
                const volatility = (Math.random() - 0.5) * 0.02;
                currentPrice *= (1 + volatility);
                futureData.push({
                    x: futureTime,
                    y: currentPrice
                });
            }

            charts.predictionChart = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'ê³¼ê±° ë°ì´í„°',
                        data: historicalData.map(d => ({x: d.timestamp, y: d.price})),
                        borderColor: 'rgb(255, 215, 0)',
                        backgroundColor: 'rgba(255, 215, 0, 0.1)'
                    }, {
                        label: 'ì˜ˆì¸¡ ë°ì´í„°',
                        data: futureData,
                        borderColor: 'rgb(255, 107, 107)',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        borderDash: [5, 5]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { labels: { color: '#fff' } }
                    },
                    scales: {
                        x: { 
                            type: 'time',
                            ticks: { color: '#fff' }
                        },
                        y: { ticks: { color: '#fff' } }
                    }
                }
            });
        }

        // ì•™ìƒë¸” ëª¨ë¸ ê´€ë ¨ í•¨ìˆ˜ë“¤
        function updateWeightSliders() {
            const sliders = ['lstm', 'gru', 'rf', 'linear'];
            sliders.forEach(model => {
                const slider = document.getElementById(model + 'Weight');
                const valueSpan = document.getElementById(model + 'WeightValue');
                
                slider.oninput = function() {
                    valueSpan.textContent = this.value;
                    normalizeWeights();
                };
            });
        }

        function normalizeWeights() {
            const sliders = ['lstm', 'gru', 'rf', 'linear'];
            let total = 0;
            
            sliders.forEach(model => {
                total += parseFloat(document.getElementById(model + 'Weight').value);
            });
            
            // ê°€ì¤‘ì¹˜ ì •ê·œí™” (ì´í•©ì´ 1ì´ ë˜ë„ë¡)
            if (total > 0) {
                sliders.forEach(model => {
                    const slider = document.getElementById(model + 'Weight');
                    const valueSpan = document.getElementById(model + 'WeightValue');
                    const normalizedValue = (parseFloat(slider.value) / total).toFixed(2);
                    valueSpan.textContent = normalizedValue;
                });
            }
        }

        function trainEnsemble() {
            if (Object.keys(models.regression).length < 2) {
                showAlert('error', 'ì•™ìƒë¸”ì„ ìœ„í•´ ìµœì†Œ 2ê°œì˜ íšŒê·€ ëª¨ë¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                return;
            }

            models.ensemble = {
                models: {...models.regression},
                weights: {
                    lstm: parseFloat(document.getElementById('lstmWeightValue').textContent),
                    gru: parseFloat(document.getElementById('gruWeightValue').textContent),
                    rf: parseFloat(document.getElementById('rfWeightValue').textContent),
                    linear: parseFloat(document.getElementById('linearWeightValue').textContent)
                },
                predict: function(data) {
                    let weightedSum = 0;
                    let totalWeight = 0;
                    
                    Object.entries(this.models).forEach(([modelType, model]) => {
                        const weight = this.weights[modelType] || 0;
                        if (weight > 0) {
                            weightedSum += model.predict(data) * weight;
                            totalWeight += weight;
                        }
                    });
                    
                    return totalWeight > 0 ? weightedSum / totalWeight : 0;
                }
            };

            showAlert('success', 'ì•™ìƒë¸” ëª¨ë¸ì´ ì„±ê³µì ìœ¼ë¡œ êµ¬ì„±ë˜ì—ˆìŠµë‹ˆë‹¤.');
            updateEnsembleCharts();
        }

        function runEnsemblePrediction() {
            if (!models.ensemble) {
                showAlert('error', 'ë¨¼ì € ì•™ìƒë¸” ëª¨ë¸ì„ í›ˆë ¨í•´ì£¼ì„¸ìš”.');
                return;
            }

            const prediction = models.ensemble.predict(cryptoData);
            showAlert('success', `ì•™ìƒë¸” ì˜ˆì¸¡: ${prediction.toFixed(2)}`);
        }

        function trainStackingEnsemble() {
            const metaModel = document.getElementById('metaModel').value;
            showAlert('warning', `${metaModel} ë©”íƒ€ ëª¨ë¸ë¡œ ìŠ¤íƒœí‚¹ ì•™ìƒë¸”ì„ í›ˆë ¨ ì¤‘...`);
            
            setTimeout(() => {
                showAlert('success', 'ìŠ¤íƒœí‚¹ ì•™ìƒë¸”ì´ ì„±ê³µì ìœ¼ë¡œ í›ˆë ¨ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }, 3000);
        }

        function updateEnsembleCharts() {
            // ì•™ìƒë¸” ì„±ëŠ¥ ì°¨íŠ¸
            const ctx1 = document.getElementById('ensemblePerformanceChart').getContext('2d');
            if (charts.ensemblePerformance) charts.ensemblePerformance.destroy();

            charts.ensemblePerformance = new Chart(ctx1, {
                type: 'radar',
                data: {
                    labels: ['ì •í™•ë„', 'RMSE', 'MAE', 'ì•ˆì •ì„±', 'ìˆ˜ë ´ì„±'],
                    datasets: [{
                        label: 'ì•™ìƒë¸” ëª¨ë¸',
                        data: [85, 75, 80, 90, 88],
                        borderColor: 'rgb(255, 215, 0)',
                        backgroundColor: 'rgba(255, 215, 0, 0.2)'
                    }, {
                        label: 'ë‹¨ì¼ ëª¨ë¸ í‰ê· ',
                        data: [70, 65, 70, 75, 72],
                        borderColor: 'rgb(78, 205, 196)',
                        backgroundColor: 'rgba(78, 205, 196, 0.2)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: { r: { ticks: { color: '#fff' } } }
                }
            });

            // ëª¨ë¸ë³„ ê¸°ì—¬ë„ ì°¨íŠ¸
            const ctx2 = document.getElementById('modelContributionChart').getContext('2d');
            if (charts.modelContribution) charts.modelContribution.destroy();

            charts.modelContribution = new Chart(ctx2, {
                type: 'doughnut',
                data: {
                    labels: ['LSTM', 'GRU', 'Random Forest', 'Linear'],
                    datasets: [{
                        data: [
                            parseFloat(document.getElementById('lstmWeightValue').textContent),
                            parseFloat(document.getElementById('gruWeightValue').textContent),
                            parseFloat(document.getElementById('rfWeightValue').textContent),
                            parseFloat(document.getElementById('linearWeightValue').textContent)
                        ],
                        backgroundColor: ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } }
                }
            });
        }

        // ë°±í…ŒìŠ¤íŒ… í•¨ìˆ˜ë“¤
        function runBacktest() {
            if (cryptoData.length === 0) {
                showAlert('error', 'ë¨¼ì € ë°ì´í„°ë¥¼ ë¡œë“œí•´ì£¼ì„¸ìš”.');
                return;
            }

            const initialCapital = parseFloat(document.getElementById('initialCapital').value);
            const tradingFee = parseFloat(document.getElementById('tradingFee').value) / 100;
            const rebalancePeriod = parseInt(document.getElementById('rebalancePeriod').value);

            showAlert('warning', 'ë°±í…ŒìŠ¤íŒ…ì„ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤...');

            setTimeout(() => {
                // ëª¨ì˜ ë°±í…ŒìŠ¤íŒ… ê²°ê³¼
                const results = {
                    totalReturn: ((Math.random() * 0.5 + 0.1) * 100).toFixed(2) + '%',
                    sharpeRatio: (Math.random() * 1.5 + 0.5).toFixed(2),
                    maxDrawdown: (-(Math.random() * 0.3 + 0.05) * 100).toFixed(2) + '%',
                    winRate: (Math.random() * 40 + 50).toFixed(1) + '%',
                    aiStrategy: (Math.random() * 50 + 10).toFixed(2) + '%',
                    holdStrategy: (Math.random() * 30 + 5).toFixed(2) + '%',
                    maStrategy: (Math.random() * 25 + 8).toFixed(2) + '%'
                };

                document.getElementById('backtestResults').style.display = 'block';
                document.getElementById('totalReturn').textContent = results.totalReturn;
                document.getElementById('sharpeRatio').textContent = results.sharpeRatio;
                document.getElementById('maxDrawdown').textContent = results.maxDrawdown;
                document.getElementById('winRate').textContent = results.winRate;
                
                document.getElementById('aiStrategyReturn').textContent = results.aiStrategy;
                document.getElementById('holdStrategyReturn').textContent = results.holdStrategy;
                document.getElementById('maStrategyReturn').textContent = results.maStrategy;

                updateReturnsChart();
                showAlert('success', 'ë°±í…ŒìŠ¤íŒ…ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.');
            }, 3000);
        }

        function updateReturnsChart() {
            const ctx = document.getElementById('returnsChart').getContext('2d');
            if (charts.returnsChart) charts.returnsChart.destroy();

            // ëª¨ì˜ ìˆ˜ìµë¥  ë°ì´í„° ìƒì„±
            const dates = [];
            const aiReturns = [];
            const holdReturns = [];
            const maReturns = [];

            for (let i = 0; i < 365; i++) {
                const date = new Date();
                date.setDate(date.getDate() - (365 - i));
                dates.push(date.toLocaleDateString());

                // ëˆ„ì  ìˆ˜ìµë¥  ì‹œë®¬ë ˆì´ì…˜
                aiReturns.push((Math.random() * 2 - 0.5 + aiReturns[i-1] || 0));
                holdReturns.push((Math.random() * 1 - 0.2 + holdReturns[i-1] || 0));
                maReturns.push((Math.random() * 1.5 - 0.3 + maReturns[i-1] || 0));
            }

            charts.returnsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: dates,
                    datasets: [{
                        label: 'AI ì „ëµ',
                        data: aiReturns,
                        borderColor: '#FF6B6B',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)'
                    }, {
                        label: 'Buy & Hold',
                        data: holdReturns,
                        borderColor: '#4ECDC4',
                        backgroundColor: 'rgba(78, 205, 196, 0.1)'
                    }, {
                        label: 'ì´ë™í‰ê·  ì „ëµ',
                        data: maReturns,
                        borderColor: '#45B7D1',
                        backgroundColor: 'rgba(69, 183, 209, 0.1)'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { ticks: { color: '#fff' } },
                        y: { ticks: { color: '#fff' } }
                    }
                }
            });
        }

        // ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í•¨ìˆ˜ë“¤
        function toggleRealtime() {
            const button = document.getElementById('realtimeToggle');
            const status = document.getElementById('realtimeStatus');

            if (!isRealtimeActive) {
                isRealtimeActive = true;
                button.textContent = 'ì¤‘ì§€';
                button.classList.add('btn-secondary');
                status.style.display = 'block';
                startRealtimeMonitoring();
                showAlert('success', 'ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ì´ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤.');
            } else {
                isRealtimeActive = false;
                button.textContent = 'ì‹œì‘';
                button.classList.remove('btn-secondary');
                status.style.display = 'none';
                stopRealtimeMonitoring();
                showAlert('warning', 'ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }

        function startRealtimeMonitoring() {
            updateRealtimeChart();
            
            realtimeInterval = setInterval(() => {
                if (cryptoData.length > 0) {
                    // ìƒˆ ë°ì´í„° í¬ì¸íŠ¸ ì¶”ê°€
                    const lastPrice = cryptoData[cryptoData.length - 1].price;
                    const newPrice = lastPrice * (1 + (Math.random() - 0.5) * 0.02);
                    const newTimestamp = new Date();

                    const newPoint = {
                        timestamp: newTimestamp,
                        open: lastPrice,
                        high: Math.max(lastPrice, newPrice),
                        low: Math.min(lastPrice, newPrice),
                        close: newPrice,
                        volume: Math.random() * 1000000 + 500000,
                        price: newPrice
                    };

                    cryptoData.push(newPoint);
                    
                    // ì˜¤ë˜ëœ ë°ì´í„° ì œê±° (ìµœê·¼ 1000ê°œë§Œ ìœ ì§€)
                    if (cryptoData.length > 1000) {
                        cryptoData.shift();
                    }

                    updateRealtimeDisplay(newPrice);
                    updateRealtimeChart();
                }
            }, 5000); // 5ì´ˆë§ˆë‹¤ ì—…ë°ì´íŠ¸
        }

        function stopRealtimeMonitoring() {
            if (realtimeInterval) {
                clearInterval(realtimeInterval);
                realtimeInterval = null;
            }
        }

        function updateRealtimeDisplay(price) {
            document.getElementById('realtimePrediction').textContent = `${price.toFixed(2)}`;
            document.getElementById('lastUpdate').textContent = new Date().toLocaleTimeString();

            // ì•Œë¦¼ í™•ì¸
            checkPriceAlerts(price);
        }

        function updateRealtimeChart() {
            const ctx = document.getElementById('realtimeChart').getContext('2d');
            
            if (charts.realtimeChart) {
                charts.realtimeChart.destroy();
            }

            const recentData = cryptoData.slice(-100); // ìµœê·¼ 100ê°œ ë°ì´í„°

            charts.realtimeChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: recentData.map(d => d.timestamp.toLocaleTimeString()),
                    datasets: [{
                        label: 'ì‹¤ì‹œê°„ ê°€ê²©',
                        data: recentData.map(d => d.price),
                        borderColor: '#FF6B6B',
                        backgroundColor: 'rgba(255, 107, 107, 0.1)',
                        tension: 0.1,
                        pointRadius: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: { duration: 0 }, // ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ì• ë‹ˆë©”ì´ì…˜ ë¹„í™œì„±í™”
                    plugins: { legend: { labels: { color: '#fff' } } },
                    scales: {
                        x: { 
                            ticks: { 
                                color: '#fff',
                                maxTicksLimit: 10
                            }
                        },
                        y: { ticks: { color: '#fff' } }
                    }
                }
            });
        }

        function checkPriceAlerts(currentPrice) {
            const upperAlert = parseFloat(document.getElementById('priceAlertUpper').value);
            const lowerAlert = parseFloat(document.getElementById('priceAlertLower').value);

            if (upperAlert && currentPrice >= upperAlert) {
                showAlert('warning', `ê°€ê²© ìƒí•œ ì•Œë¦¼: ${currentPrice.toFixed(2)}`);
                playNotificationSound();
            }

            if (lowerAlert && currentPrice <= lowerAlert) {
                showAlert('warning', `ê°€ê²© í•˜í•œ ì•Œë¦¼: ${currentPrice.toFixed(2)}`);
                playNotificationSound();
            }
        }

        function setAlerts() {
            const upper = document.getElementById('priceAlertUpper').value;
            const lower = document.getElementById('priceAlertLower').value;
            const volatility = document.getElementById('volatilityAlert').value;

            showAlert('success', 'ì•Œë¦¼ì´ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.');
        }

        function configAutoTrading() {
            const autoTrading = document.getElementById('autoTrading').value === 'true';
            const maxPosition = document.getElementById('maxPosition').value;
            const stopLoss = document.getElementById('stopLoss').value;
            const takeProfit = document.getElementById('takeProfit').value;

            if (autoTrading) {
                showAlert('warning', 'ìë™ê±°ë˜ê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ì‹¤ì œ ê±°ë˜ëŠ” ì‹ ì¤‘í•˜ê²Œ ì§„í–‰í•˜ì„¸ìš”.');
            } else {
                showAlert('success', 'ìë™ê±°ë˜ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }

        function playNotificationSound() {
            // ë¸Œë¼ìš°ì € ì•Œë¦¼ìŒ ì¬ìƒ (ì‹¤ì œ êµ¬í˜„ì‹œ ì‚¬ìš©)
            if ('Notification' in window) {
                new Notification('CryptoAI ì•Œë¦¼', {
                    body: 'ê°€ê²© ì•Œë¦¼ì´ íŠ¸ë¦¬ê±°ë˜ì—ˆìŠµë‹ˆë‹¤.',
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">ğŸš€</text></svg>'
                });
            }
        }

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        function showAlert(type, message) {
            const alertDiv = document.createElement('div');
            alertDiv.className = `alert alert-${type}`;
            alertDiv.textContent = message;
            alertDiv.style.position = 'fixed';
            alertDiv.style.top = '20px';
            alertDiv.style.right = '20px';
            alertDiv.style.zIndex = '9999';
            alertDiv.style.minWidth = '300px';

            document.body.appendChild(alertDiv);

            setTimeout(() => {
                alertDiv.remove();
            }, 5000);
        }

        // ê³ ê¸‰ ë¶„ì„ ê¸°ëŠ¥ë“¤
        function calculateTechnicalIndicators() {
            if (cryptoData.length < 50) return {};

            const prices = cryptoData.map(d => d.price);
            const volumes = cryptoData.map(d => d.volume);

            return {
                sma20: calculateSMA(prices, 20),
                sma50: calculateSMA(prices, 50),
                ema12: calculateEMA(prices, 12),
                ema26: calculateEMA(prices, 26),
                rsi: calculateRSI(prices, 14),
                macd: calculateMACD(prices),
                bollinger: calculateBollingerBands(prices, 20),
                volume_sma: calculateSMA(volumes, 20)
            };
        }

        function calculateSMA(data, period) {
            const sma = [];
            for (let i = period - 1; i < data.length; i++) {
                const sum = data.slice(i - period + 1, i + 1).reduce((a, b) => a + b, 0);
                sma.push(sum / period);
            }
            return sma;
        }

        function calculateEMA(data, period) {
            const ema = [data[0]];
            const multiplier = 2 / (period + 1);
            
            for (let i = 1; i < data.length; i++) {
                ema.push((data[i] * multiplier) + (ema[i - 1] * (1 - multiplier)));
            }
            return ema;
        }

        function calculateRSI(data, period) {
            const gains = [];
            const losses = [];
            
            for (let i = 1; i < data.length; i++) {
                const difference = data[i] - data[i - 1];
                gains.push(difference > 0 ? difference : 0);
                losses.push(difference < 0 ? Math.abs(difference) : 0);
            }

            const avgGains = calculateSMA(gains, period);
            const avgLosses = calculateSMA(losses, period);
            
            return avgGains.map((gain, i) => {
                const rs = gain / avgLosses[i];
                return 100 - (100 / (1 + rs));
            });
        }

        function calculateMACD(data) {
            const ema12 = calculateEMA(data, 12);
            const ema26 = calculateEMA(data, 26);
            
            const macd = [];
            const minLength = Math.min(ema12.length, ema26.length);
            
            for (let i = 0; i < minLength; i++) {
                macd.push(ema12[i] - ema26[i]);
            }
            
            const signal = calculateEMA(macd, 9);
            const histogram = macd.slice(-signal.length).map((val, i) => val - signal[i]);
            
            return { macd, signal, histogram };
        }

        function calculateBollingerBands(data, period) {
            const sma = calculateSMA(data, period);
            const bands = [];
            
            for (let i = period - 1; i < data.length; i++) {
                const slice = data.slice(i - period + 1, i + 1);
                const mean = slice.reduce((a, b) => a + b, 0) / period;
                const variance = slice.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / period;
                const stdDev = Math.sqrt(variance);
                
                bands.push({
                    upper: sma[i - period + 1] + (stdDev * 2),
                    middle: sma[i - period + 1],
                    lower: sma[i - period + 1] - (stdDev * 2)
                });
            }
            
            return bands;
        }

        // ê³ ê¸‰ ML ëª¨ë¸ ì‹œë®¬ë ˆì´ì…˜
        function createAdvancedModels() {
            return {
                transformer: {
                    name: 'Transformer',
                    accuracy: 0.89,
                    predict: (data) => simulateAdvancedPrediction(data, 'transformer')
                },
                lstm_attention: {
                    name: 'LSTM with Attention',
                    accuracy: 0.87,
                    predict: (data) => simulateAdvancedPrediction(data, 'lstm_attention')
                },
                gru_bidirectional: {
                    name: 'Bidirectional GRU',
                    accuracy: 0.85,
                    predict: (data) => simulateAdvancedPrediction(data, 'gru_bidirectional')
                },
                cnn_lstm: {
                    name: 'CNN-LSTM Hybrid',
                    accuracy: 0.84,
                    predict: (data) => simulateAdvancedPrediction(data, 'cnn_lstm')
                },
                wavenet: {
                    name: 'WaveNet',
                    accuracy: 0.86,
                    predict: (data) => simulateAdvancedPrediction(data, 'wavenet')
                }
            };
        }

        function simulateAdvancedPrediction(data, modelType) {
            const lastPrice = data[data.length - 1].price;
            const indicators = calculateTechnicalIndicators();
            
            // ëª¨ë¸ë³„ íŠ¹ì„±ì„ ë°˜ì˜í•œ ì˜ˆì¸¡ ë¡œì§
            let prediction;
            switch(modelType) {
                case 'transformer':
                    prediction = lastPrice * (1 + (Math.random() - 0.48) * 0.1); // ì•½ê°„ ìƒìŠ¹ í¸í–¥
                    break;
                case 'lstm_attention':
                    prediction = lastPrice * (1 + (Math.random() - 0.5) * 0.08); // ë³´ìˆ˜ì  ì˜ˆì¸¡
                    break;
                case 'gru_bidirectional':
                    prediction = lastPrice * (1 + (Math.random() - 0.49) * 0.09); // ê· í˜•ì¡íŒ ì˜ˆì¸¡
                    break;
                case 'cnn_lstm':
                    prediction = lastPrice * (1 + (Math.random() - 0.51) * 0.12); // ë³€ë™ì„± í° ì˜ˆì¸¡
                    break;
                case 'wavenet':
                    prediction = lastPrice * (1 + (Math.random() - 0.47) * 0.07); // ìƒìŠ¹ í¸í–¥, ì•ˆì •ì 
                    break;
                default:
                    prediction = lastPrice * (1 + (Math.random() - 0.5) * 0.1);
            }
            
            return Math.max(prediction, 0); // ìŒìˆ˜ ê°€ê²© ë°©ì§€
        }

        // í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”
        function optimizePortfolio() {
            const assets = ['BTC', 'ETH', 'BNB', 'ADA', 'SOL'];
            const returns = assets.map(() => Math.random() * 0.3 + 0.05); // 5-35% ì—°ìˆ˜ìµë¥ 
            const risks = assets.map(() => Math.random() * 0.4 + 0.1); // 10-50% ë³€ë™ì„±
            
            // ê°„ë‹¨í•œ ë§ˆë¥´ì½”ìœ„ì¸  ìµœì í™” ì‹œë®¬ë ˆì´ì…˜
            const weights = optimizeMarkovitz(returns, risks);
            
            return {
                assets,
                weights,
                expectedReturn: weights.reduce((sum, w, i) => sum + w * returns[i], 0),
                expectedRisk: Math.sqrt(weights.reduce((sum, w, i) => sum + Math.pow(w * risks[i], 2), 0))
            };
        }

        function optimizeMarkovitz(returns, risks) {
            // ë¦¬ìŠ¤í¬ íŒ¨ë¦¬í‹° ê¸°ë°˜ ê°„ë‹¨í•œ ê°€ì¤‘ì¹˜ ê³„ì‚°
            const invRisks = risks.map(r => 1 / r);
            const sumInvRisks = invRisks.reduce((a, b) => a + b, 0);
            return invRisks.map(ir => ir / sumInvRisks);
        }

        // ìœ„í—˜ ê´€ë¦¬ ì‹œìŠ¤í…œ
        function calculateVaR(data, confidence = 0.95) {
            const returns = [];
            for (let i = 1; i < data.length; i++) {
                returns.push((data[i].price - data[i-1].price) / data[i-1].price);
            }
            
            returns.sort((a, b) => a - b);
            const index = Math.floor((1 - confidence) * returns.length);
            return returns[index];
        }

        function calculateMaxDrawdown(data) {
            let maxDrawdown = 0;
            let peak = data[0].price;
            
            for (let i = 1; i < data.length; i++) {
                if (data[i].price > peak) {
                    peak = data[i].price;
                } else {
                    const drawdown = (peak - data[i].price) / peak;
                    maxDrawdown = Math.max(maxDrawdown, drawdown);
                }
            }
            
            return maxDrawdown;
        }

        // ê°ì • ë¶„ì„ ì‹œë®¬ë ˆì´ì…˜
        function analyzeSentiment() {
            const sentiments = ['ë§¤ìš° ê¸ì •', 'ê¸ì •', 'ì¤‘ë¦½', 'ë¶€ì •', 'ë§¤ìš° ë¶€ì •'];
            const weights = [0.1, 0.3, 0.4, 0.15, 0.05]; // ê°€ì¤‘ì¹˜
            
            let random = Math.random();
            let cumulativeWeight = 0;
            
            for (let i = 0; i < weights.length; i++) {
                cumulativeWeight += weights[i];
                if (random <= cumulativeWeight) {
                    return {
                        sentiment: sentiments[i],
                        score: (i - 2) / 2, // -1 ~ 1 ìŠ¤ì½”ì–´
                        confidence: Math.random() * 0.3 + 0.7 // 70-100% ì‹ ë¢°ë„
                    };
                }
            }
        }

        // í˜ì´ì§€ ë¡œë“œ ì‹œ ì´ˆê¸°í™”
        document.addEventListener('DOMContentLoaded', function() {
            updateWeightSliders();
            
            // ì•Œë¦¼ ê¶Œí•œ ìš”ì²­
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }

            // ê³ ê¸‰ ëª¨ë¸ ì¶”ê°€
            const advancedModels = createAdvancedModels();
            Object.assign(models.regression, advancedModels);

            showAlert('success', 'CryptoAI í”Œë«í¼ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.');
        });

        // ì¶”ê°€ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
        function exportData() {
            if (cryptoData.length === 0) {
                showAlert('error', 'ë‚´ë³´ë‚¼ ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.');
                return;
            }

            const dataStr = JSON.stringify(cryptoData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            
            const link = document.createElement('a');
            link.href = url;
            link.download = `crypto_data_${new Date().toISOString().split('T')[0]}.json`;
            link.click();
            
            URL.revokeObjectURL(url);
            showAlert('success', 'ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ë‚´ë³´ë‚´ì¡ŒìŠµë‹ˆë‹¤.');
        }

        function importData(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importedData = JSON.parse(e.target.result);
                    if (Array.isArray(importedData) && importedData.length > 0) {
                        cryptoData = importedData.map(item => ({
                            ...item,
                            timestamp: new Date(item.timestamp)
                        }));
                        updateDataPreview();
                        updatePriceChart();
                        showAlert('success', 'ë°ì´í„°ê°€ ì„±ê³µì ìœ¼ë¡œ ê°€ì ¸ì™€ì¡ŒìŠµë‹ˆë‹¤.');
                    } else {
                        throw new Error('ì˜ëª»ëœ ë°ì´í„° í˜•ì‹');
                    }
                } catch (error) {
                    showAlert('error', 'ë°ì´í„° ê°€ì ¸ì˜¤ê¸°ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: ' + error.message);
                }
            };
            reader.readAsText(file);
        }

        // í‚¤ë³´ë“œ ë‹¨ì¶•í‚¤
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case '1':
                        e.preventDefault();
                        switchTab('data');
                        break;
                    case '2':
                        e.preventDefault();
                        switchTab('models');
                        break;
                    case '3':
                        e.preventDefault();
                        switchTab('prediction');
                        break;
                    case '4':
                        e.preventDefault();
                        switchTab('ensemble');
                        break;
                    case '5':
                        e.preventDefault();
                        switchTab('backtest');
                        break;
                    case '6':
                        e.preventDefault();
                        switchTab('realtime');
                        break;
                }
            }
        });
    </script>
</body>
</html>